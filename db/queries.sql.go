// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BulkCreatePowerConsumpionParams struct {
	HomeID                      pgtype.UUID
	Power                       pgtype.Float8
	MinPower                    pgtype.Float8
	MaxPower                    pgtype.Float8
	AvgPower                    pgtype.Float8
	LastMeterConsumption        pgtype.Float8
	LastMeterProduction         pgtype.Float8
	AccumulatedConsumptionToday pgtype.Float8
	AccumulatedProductionToday  pgtype.Float8
	AccumulatedConsumptionHour  pgtype.Float8
	AccumulatedProductionHour   pgtype.Float8
	CurrentPriceFromProvider    pgtype.Float8
	AccumulatedCostToday        pgtype.Float8
	Ts                          pgtype.Timestamptz
}

const createHome = `-- name: CreateHome :one
INSERT INTO homes 
  (user_id, name, address)
VALUES 
  ($1, $2, $3)
RETURNING id, user_id, name, address, created_at, updated_at, deleted_at
`

type CreateHomeParams struct {
	UserID  int32
	Name    string
	Address string
}

func (q *Queries) CreateHome(ctx context.Context, arg CreateHomeParams) (Home, error) {
	row := q.db.QueryRow(ctx, createHome, arg.UserID, arg.Name, arg.Address)
	var i Home
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createIdentity = `-- name: CreateIdentity :one
INSERT INTO identity 
  (user_id, username, email, password_hash)
VALUES 
  ($1, $2, $3, $4)
RETURNING id, user_id, username, email, password_hash, created_at, updated_at, deleted_at
`

type CreateIdentityParams struct {
	UserID       int32
	Username     string
	Email        string
	PasswordHash string
}

func (q *Queries) CreateIdentity(ctx context.Context, arg CreateIdentityParams) (Identity, error) {
	row := q.db.QueryRow(ctx, createIdentity,
		arg.UserID,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
	)
	var i Identity
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createPowerConsumpion = `-- name: CreatePowerConsumpion :exec
INSERT INTO power_consumption (
  home_id,
  power,
  min_power,
  max_power,
  avg_power,
  last_meter_consumption,
  last_meter_production,
  accumulated_consumption_today,
  accumulated_production_today,
  accumulated_consumption_hour,
  accumulated_production_hour,
  current_price_from_provider,
  accumulated_cost_today,
  ts
)
VALUES 
  ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
`

type CreatePowerConsumpionParams struct {
	HomeID                      pgtype.UUID
	Power                       pgtype.Float8
	MinPower                    pgtype.Float8
	MaxPower                    pgtype.Float8
	AvgPower                    pgtype.Float8
	LastMeterConsumption        pgtype.Float8
	LastMeterProduction         pgtype.Float8
	AccumulatedConsumptionToday pgtype.Float8
	AccumulatedProductionToday  pgtype.Float8
	AccumulatedConsumptionHour  pgtype.Float8
	AccumulatedProductionHour   pgtype.Float8
	CurrentPriceFromProvider    pgtype.Float8
	AccumulatedCostToday        pgtype.Float8
	Ts                          pgtype.Timestamptz
}

func (q *Queries) CreatePowerConsumpion(ctx context.Context, arg CreatePowerConsumpionParams) error {
	_, err := q.db.Exec(ctx, createPowerConsumpion,
		arg.HomeID,
		arg.Power,
		arg.MinPower,
		arg.MaxPower,
		arg.AvgPower,
		arg.LastMeterConsumption,
		arg.LastMeterProduction,
		arg.AccumulatedConsumptionToday,
		arg.AccumulatedProductionToday,
		arg.AccumulatedConsumptionHour,
		arg.AccumulatedProductionHour,
		arg.CurrentPriceFromProvider,
		arg.AccumulatedCostToday,
		arg.Ts,
	)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users 
  (firstname, lastname, phone, company, address)
VALUES 
  ($1, $2, $3, $4, $5)
RETURNING id, firstname, lastname, phone, company, address, created_at, updated_at, deleted_at
`

type CreateUserParams struct {
	Firstname string
	Lastname  string
	Phone     pgtype.Text
	Company   pgtype.Text
	Address   pgtype.Text
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Firstname,
		arg.Lastname,
		arg.Phone,
		arg.Company,
		arg.Address,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Firstname,
		&i.Lastname,
		&i.Phone,
		&i.Company,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteHome = `-- name: DeleteHome :exec
UPDATE homes
  SET updated_at = NOW(), deleted_at = NOW()
`

func (q *Queries) DeleteHome(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteHome)
	return err
}

const deleteIdentiy = `-- name: DeleteIdentiy :exec
UPDATE identity
  SET updated_at = NOW(), deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteIdentiy(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteIdentiy, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
UPDATE users
  SET updated_at = NOW(), deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getHomeById = `-- name: GetHomeById :one
SELECT id, user_id, name, address, created_at, updated_at, deleted_at FROM homes WHERE id = $1
`

func (q *Queries) GetHomeById(ctx context.Context, id pgtype.UUID) (Home, error) {
	row := q.db.QueryRow(ctx, getHomeById, id)
	var i Home
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getHomesForUser = `-- name: GetHomesForUser :many
SELECT id, user_id, name, address, created_at, updated_at, deleted_at FROM homes WHERE user_id = $1
`

func (q *Queries) GetHomesForUser(ctx context.Context, userID int32) ([]Home, error) {
	rows, err := q.db.Query(ctx, getHomesForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Home
	for rows.Next() {
		var i Home
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Address,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIdentity = `-- name: GetIdentity :one
SELECT id, user_id, username, email, password_hash, created_at, updated_at, deleted_at FROM identity WHERE username = $1 OR email = $1
`

func (q *Queries) GetIdentity(ctx context.Context, username string) (Identity, error) {
	row := q.db.QueryRow(ctx, getIdentity, username)
	var i Identity
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getIdentityById = `-- name: GetIdentityById :one
SELECT id, user_id, username, email, password_hash, created_at, updated_at, deleted_at FROM identity WHERE id = $1
`

func (q *Queries) GetIdentityById(ctx context.Context, id int32) (Identity, error) {
	row := q.db.QueryRow(ctx, getIdentityById, id)
	var i Identity
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPowerConsumptionBetween = `-- name: GetPowerConsumptionBetween :many
SELECT id, home_id, power, min_power, max_power, avg_power, last_meter_consumption, last_meter_production, accumulated_consumption_today, accumulated_production_today, accumulated_consumption_hour, accumulated_production_hour, current_price_from_provider, accumulated_cost_today, ts FROM power_consumption 
WHERE 
  home_id = $1 AND 
  ts BETWEEN $2 AND $3
`

type GetPowerConsumptionBetweenParams struct {
	HomeID pgtype.UUID
	Ts     pgtype.Timestamptz
	Ts_2   pgtype.Timestamptz
}

func (q *Queries) GetPowerConsumptionBetween(ctx context.Context, arg GetPowerConsumptionBetweenParams) ([]PowerConsumption, error) {
	rows, err := q.db.Query(ctx, getPowerConsumptionBetween, arg.HomeID, arg.Ts, arg.Ts_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PowerConsumption
	for rows.Next() {
		var i PowerConsumption
		if err := rows.Scan(
			&i.ID,
			&i.HomeID,
			&i.Power,
			&i.MinPower,
			&i.MaxPower,
			&i.AvgPower,
			&i.LastMeterConsumption,
			&i.LastMeterProduction,
			&i.AccumulatedConsumptionToday,
			&i.AccumulatedProductionToday,
			&i.AccumulatedConsumptionHour,
			&i.AccumulatedProductionHour,
			&i.CurrentPriceFromProvider,
			&i.AccumulatedCostToday,
			&i.Ts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserById = `-- name: GetUserById :one
SELECT 
  u.id, u.firstname, u.lastname, u.phone, u.company, u.address,
  i.id AS identity_id, i.username, i.email,
  r.name AS role
FROM 
  users u
  JOIN identity i ON users.id = identity.user_id
  LEFT JOIN LATERAL(
    SELECT id, name, created_at, updated_at, deleted_at FROM roles inner_roles
    WHERE inner_roles.id IN (SELECT role_id FROM user_roles WHERE user_id = users.id)
    ORDER BY inner_roles.id LIMIT 1
  ) r ON true
WHERE u.id = $1
`

type GetUserByIdRow struct {
	ID         int32
	Firstname  string
	Lastname   string
	Phone      pgtype.Text
	Company    pgtype.Text
	Address    pgtype.Text
	IdentityID int32
	Username   string
	Email      string
	Role       string
}

func (q *Queries) GetUserById(ctx context.Context, id int32) (GetUserByIdRow, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i GetUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.Firstname,
		&i.Lastname,
		&i.Phone,
		&i.Company,
		&i.Address,
		&i.IdentityID,
		&i.Username,
		&i.Email,
		&i.Role,
	)
	return i, err
}

const updateHome = `-- name: UpdateHome :one
UPDATE homes
  SET name = $2, address = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, name, address, created_at, updated_at, deleted_at
`

type UpdateHomeParams struct {
	ID      pgtype.UUID
	Name    string
	Address string
}

func (q *Queries) UpdateHome(ctx context.Context, arg UpdateHomeParams) (Home, error) {
	row := q.db.QueryRow(ctx, updateHome, arg.ID, arg.Name, arg.Address)
	var i Home
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updatePassword = `-- name: UpdatePassword :exec
UPDATE identity
  SET password_hash = $2, updated_at = NOW()
WHERE id = $1
`

type UpdatePasswordParams struct {
	ID           int32
	PasswordHash string
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error {
	_, err := q.db.Exec(ctx, updatePassword, arg.ID, arg.PasswordHash)
	return err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
  SET firstname = $2, lastname = $3, phone = $4, company = $5, address = $6, updated_at = NOW()
WHERE id = $1
RETURNING id, firstname, lastname, phone, company, address, created_at, updated_at, deleted_at
`

type UpdateUserParams struct {
	ID        int32
	Firstname string
	Lastname  string
	Phone     pgtype.Text
	Company   pgtype.Text
	Address   pgtype.Text
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Firstname,
		arg.Lastname,
		arg.Phone,
		arg.Company,
		arg.Address,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Firstname,
		&i.Lastname,
		&i.Phone,
		&i.Company,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
